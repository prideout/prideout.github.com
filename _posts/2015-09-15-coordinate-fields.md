---
layout: page
tags : [opengl, rendering]
description : "Discusses an interesting way to encode unsigned distance."
thumbnail : Heman-masked.png
---
{% include JB/setup %}

<!--
    post should mention heman for CPU-based...
    mention this post in your old post
-->

[seed] => [RG image] => [Voronoi darkened by DF]

This article introduces _closest point coordinate fields_ (CPCF's), which are a simple concept related to Voronoi diagrams and distance fields.  Recently I realized that CPCF's can be magnified perfectly using a simple fragment shader, so I wanted to write something up about it.

CPCF's are useful for pick sheets and map coloration, but they might also have applications in path planning and collision detection that I haven't thought about yet.

This article is divided into three sections: Math, Shaders, and Applications.  So, scroll down if you don't like math (shame on you!).

## Math

The _Euclidean distance transform_ (EDT) can be defined as the following function, which consumes a set of seed points <math><mi>&#x1D4AE;</mi></math> and produces a value for every <math><mi>p</mi></math> in <math><msup><mi>&#x211D;</mi><mi>2</mi></msup></math>:

<math display="block">
    <mi>d</mi>
    <mfenced>
        <mi>p</mi>
    </mfenced>
    <mo>=</mo>
    <munder>
        <mi>min</mi>
        <mrow>
            <mi>q</mi>
            <mo>&#x2208;</mo>
            <mi>&#x1D4AE;</mi>
        </mrow>
    </munder>
    <mfenced open="&#x2225;" close="&#x2225;" separators="">
        <mi>p</mi><mo>-</mo><mi>q</mi>
    </mfenced>
</math>

Sampling the above function over a grid results in an unsigned distance field.  (As opposed to a _signed distance field_, which can be generated by composing it with an EDT that uses the complement of <math><mi>&#x1D4AE;</mi></math>.)

[Felzenszwalb and Huttenlocher](http://cs.brown.edu/~pff/dt/index.html) generalized this into the following equation, which is easiest to understand when considering a function <math><mi>f</mi></math> that returns 0 if its input is in  &#x1D4AE;, and &#x221E; otherwise.

<math display="block">
<mrow>
<mi>d</mi>
<mfenced>
    <mi>p</mi>
</mfenced>
<mo>=</mo>
<munder>
    <mi>min</mi>
    <mrow>
        <mi>q</mi>
        <mo>&#x2208;</mo>
        <msup><mi>&#x211D;</mi><mi>2</mi></msup>
    </mrow>
</munder>
<mfenced>
  <mrow>
    <mfenced open="&#x2225;" close="&#x2225;" separators="">
        <mi>p</mi><mo>-</mo><mi>q</mi>
    </mfenced>
    <mo>+</mo>
    <mi>f</mi>
    <mfenced>
        <mi>q</mi>
    </mfenced>
  </mrow>
</mfenced>
</mrow>
</math>

This led to their linear-time algorithm, which is probably the best way to generate the SDF on a CPU, because it's simple and fast.

Next I'd like to introduce a new function that leverages the EDT function, but produces a set of coordinates instead of a scalar value:

<math display="block">
    <mi>g</mi><mfenced><mi>p</mi></mfenced>
    <mo>=</mo>
    <mo>{</mo>
    <mi>q</mi>
    <mo>&#x2208;</mo>
    <mi>&#x1D4AE;</mi>
    <mspace depth="0.5ex" height="0.5ex" width="1ex">
    </mspace>
    <mo>|</mo>
    <mspace depth="0.5ex" height="0.5ex" width="1ex">
    </mspace>
    <mi>d</mi><mfenced><mi>q</mi></mfenced>
    <mo>=</mo>
    <mi>d</mi><mfenced><mi>p</mi></mfenced>
    <mo>}</mo>
</math>

In practice, evaluating the above function usually results in a set that has only one element.  The set has multiple items only when several seed points "tie for first place".  This occurs along the edges of the Voronoi diagram produced by <math><mi>&#x1D4AE;</mi></math>.

Let's just pick a random tiebreaker from each set; we'll call this <math><msub><mi>g</mi><mn>0</mn></msub></math> instead of <math><mi>g</mi></math>.  If we sample <math><msub><mi>g</mi><mn>0</mn></msub></math> over a grid, the result is the CPCF.

The CPCF is cool because it can be trivially transformed into a distance field, but it encodes more information than a distance field.  Another cool thing about CPCF's is that they result from the [Rong and Tan](http://) algorithm, which is probably the fastest way to compute a distance field on a GPU.

Here's how to transform a CPCF into a distance field:

<math display="block">
    <mi>d</mi><mfenced><mi>p</mi></mfenced>
    <mo>=</mo>
    <mfenced open="&#x2225;" close="&#x2225;" separators="">
        <mi>p</mi>
        <mo>-</mo>
        <msub><mi>g</mi><mn>0</mn></msub>
        <mfenced><mi>p</mi></mfenced>
    </mfenced>
</math>

## Shaders

Here's a picture of a seed image, its resulting CPCF, and finally, the distance field implied by the CPCF:

[image] => [RG image] => [DF image]

In GLSL, this transformation looks like this:

    dist = distance(uv, texture(coordfield, uv));
    gl_FragColor = vec4(dist, dist, dist, 1);

Voronoi diagrams can also be trivially derived from coordinate fields:

[image] => [RG image] => [Voronoi image]

In GLSL, this transformation looks like this:

    vec2 st = texture(coordfield, uv);
    gl_FragColor = texture(seed, st);

# Applications

## Picking

![DistancePicking Screenshot]({{ BASE_PATH }}/assets/thumbnails/DistancePicking-halved.png)

If the user moves the cursor around in the canvas, the demo performs an O(1) lookup into the coordinate field to find the nearest point, then draws a line to that point.  This technique is potentially very useful when implementing object selection.

## Infinite Zoom

Another nice thing about coordinate fields is that they can be perfectly magnified.

Note that sub-pixel accuracy is possible, if you encode a floating-point coordinate when generating the seed image!

## Noisy Coordinate Fields

Political boundaries.

Link to heman here.

<!--
We use some of the techniques in this post to generate the maps at [mappable.com](http://mappable.com), which you should definitely check out if you're into music!
-->